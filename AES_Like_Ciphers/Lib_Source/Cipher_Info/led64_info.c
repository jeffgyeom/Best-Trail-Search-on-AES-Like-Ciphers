#include "astbb.h"
#include "dif_prob.h"
#include "lin_corr.h"



SBOX_O_WRD_t LED64_sboxes[16 * 16] =
{
	0xC, 0x5, 0x6, 0xB, 0x9, 0x0, 0xA, 0xD, 0x3, 0xE, 0xF, 0x8, 0x4, 0x7, 0x1, 0x2,
	0xC, 0x5, 0x6, 0xB, 0x9, 0x0, 0xA, 0xD, 0x3, 0xE, 0xF, 0x8, 0x4, 0x7, 0x1, 0x2,
	0xC, 0x5, 0x6, 0xB, 0x9, 0x0, 0xA, 0xD, 0x3, 0xE, 0xF, 0x8, 0x4, 0x7, 0x1, 0x2,
	0xC, 0x5, 0x6, 0xB, 0x9, 0x0, 0xA, 0xD, 0x3, 0xE, 0xF, 0x8, 0x4, 0x7, 0x1, 0x2,

	0xC, 0x5, 0x6, 0xB, 0x9, 0x0, 0xA, 0xD, 0x3, 0xE, 0xF, 0x8, 0x4, 0x7, 0x1, 0x2,
	0xC, 0x5, 0x6, 0xB, 0x9, 0x0, 0xA, 0xD, 0x3, 0xE, 0xF, 0x8, 0x4, 0x7, 0x1, 0x2,
	0xC, 0x5, 0x6, 0xB, 0x9, 0x0, 0xA, 0xD, 0x3, 0xE, 0xF, 0x8, 0x4, 0x7, 0x1, 0x2,
	0xC, 0x5, 0x6, 0xB, 0x9, 0x0, 0xA, 0xD, 0x3, 0xE, 0xF, 0x8, 0x4, 0x7, 0x1, 0x2,

	0xC, 0x5, 0x6, 0xB, 0x9, 0x0, 0xA, 0xD, 0x3, 0xE, 0xF, 0x8, 0x4, 0x7, 0x1, 0x2,
	0xC, 0x5, 0x6, 0xB, 0x9, 0x0, 0xA, 0xD, 0x3, 0xE, 0xF, 0x8, 0x4, 0x7, 0x1, 0x2,
	0xC, 0x5, 0x6, 0xB, 0x9, 0x0, 0xA, 0xD, 0x3, 0xE, 0xF, 0x8, 0x4, 0x7, 0x1, 0x2,
	0xC, 0x5, 0x6, 0xB, 0x9, 0x0, 0xA, 0xD, 0x3, 0xE, 0xF, 0x8, 0x4, 0x7, 0x1, 0x2,

	0xC, 0x5, 0x6, 0xB, 0x9, 0x0, 0xA, 0xD, 0x3, 0xE, 0xF, 0x8, 0x4, 0x7, 0x1, 0x2,
	0xC, 0x5, 0x6, 0xB, 0x9, 0x0, 0xA, 0xD, 0x3, 0xE, 0xF, 0x8, 0x4, 0x7, 0x1, 0x2,
	0xC, 0x5, 0x6, 0xB, 0x9, 0x0, 0xA, 0xD, 0x3, 0xE, 0xF, 0x8, 0x4, 0x7, 0x1, 0x2,
	0xC, 0x5, 0x6, 0xB, 0x9, 0x0, 0xA, 0xD, 0x3, 0xE, 0xF, 0x8, 0x4, 0x7, 0x1, 0x2,
};




//FIELD_MUL
static DIFF_O_WRD_t MUL[16][16] = {
	//0x0 times x
	{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,},
	//0x1 times x
	{0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xA, 0xB, 0xC, 0xD, 0xE, 0xF,},
	//0x2 times x
	{0x0, 0x2, 0x4, 0x6, 0x8, 0xA, 0xC, 0xE, 0x3, 0x1, 0x7, 0x5, 0xB, 0x9, 0xF, 0xD,},
	//0x3 times x
	{0x0, 0x3, 0x6, 0x5, 0xC, 0xF, 0xA, 0x9, 0xB, 0x8, 0xD, 0xE, 0x7, 0x4, 0x1, 0x2,},
	//0x4 times x
	{0x0, 0x4, 0x8, 0xC, 0x3, 0x7, 0xB, 0xF, 0x6, 0x2, 0xE, 0xA, 0x5, 0x1, 0xD, 0x9,},
	//0x5 times x
	{0x0, 0x5, 0xA, 0xF, 0x7, 0x2, 0xD, 0x8, 0xE, 0xB, 0x4, 0x1, 0x9, 0xC, 0x3, 0x6,},
	//0x6 times x
	{0x0, 0x6, 0xC, 0xA, 0xB, 0xD, 0x7, 0x1, 0x5, 0x3, 0x9, 0xF, 0xE, 0x8, 0x2, 0x4,},
	//0x7 times x
	{0x0, 0x7, 0xE, 0x9, 0xF, 0x8, 0x1, 0x6, 0xD, 0xA, 0x3, 0x4, 0x2, 0x5, 0xC, 0xB,},
	//0x8 times x
	{0x0, 0x8, 0x3, 0xB, 0x6, 0xE, 0x5, 0xD, 0xC, 0x4, 0xF, 0x7, 0xA, 0x2, 0x9, 0x1,},
	//0x9 times x
	{0x0, 0x9, 0x1, 0x8, 0x2, 0xB, 0x3, 0xA, 0x4, 0xD, 0x5, 0xC, 0x6, 0xF, 0x7, 0xE,},
	//0xa times x
	{0x0, 0xA, 0x7, 0xD, 0xE, 0x4, 0x9, 0x3, 0xF, 0x5, 0x8, 0x2, 0x1, 0xB, 0x6, 0xC,},
	//0xb times x
	{0x0, 0xB, 0x5, 0xE, 0xA, 0x1, 0xF, 0x4, 0x7, 0xC, 0x2, 0x9, 0xD, 0x6, 0x8, 0x3,},
	//0xc times x
	{0x0, 0xC, 0xB, 0x7, 0x5, 0x9, 0xE, 0x2, 0xA, 0x6, 0x1, 0xD, 0xF, 0x3, 0x4, 0x8,},
	//0xd times x
	{0x0, 0xD, 0x9, 0x4, 0x1, 0xC, 0x8, 0x5, 0x2, 0xF, 0xB, 0x6, 0x3, 0xE, 0xA, 0x7,},
	//0xe times x
	{0x0, 0xE, 0xF, 0x1, 0xD, 0x3, 0x2, 0xC, 0x9, 0x7, 0x6, 0x8, 0x4, 0xA, 0xB, 0x5,},
	//0xf times x
	{0x0, 0xF, 0xD, 0x2, 0x9, 0x6, 0x4, 0xB, 0x1, 0xE, 0xC, 0x3, 0x8, 0x7, 0x5, 0xA,},
};

//w0, w4, w8, w12, w1, w5, w9, w13, w2, w6, w10, w14, w3, w7, w11, w15
//||  ||  ||   ||  ||  ||  ||   ||  ||  ||   ||   ||  ||  ||   ||   ||
//o0, o1, o2,  o3, o4, o5, o6,  o7, o8, o9, o10, o11,o12,o13, o14, o15
void LED64_diffusion(DIFF_O_WRD_t * out, DIFF_I_WRD_t * in)
{
	DIFF_I_WRD_t temp[16];

	/*
		0 1 0 0 ^4  = 4 1 2 2
		0 0 1 0       8 6 5 6
		0 0 0 1       B E A 9
		4 1 2 2       2 2 F B
	*/

	//Mix Column
	temp[0] = MUL[0x4][in[0]] ^ MUL[0x1][in[1]] ^ MUL[0x2][in[2]] ^ MUL[0x2][in[3]];
	temp[1] = MUL[0x8][in[0]] ^ MUL[0x6][in[1]] ^ MUL[0x5][in[2]] ^ MUL[0x6][in[3]];
	temp[2] = MUL[0xB][in[0]] ^ MUL[0xE][in[1]] ^ MUL[0xA][in[2]] ^ MUL[0x9][in[3]];
	temp[3] = MUL[0x2][in[0]] ^ MUL[0x2][in[1]] ^ MUL[0xF][in[2]] ^ MUL[0xB][in[3]];

	temp[4] = MUL[0x4][in[4]] ^ MUL[0x1][in[5]] ^ MUL[0x2][in[6]] ^ MUL[0x2][in[7]];
	temp[5] = MUL[0x8][in[4]] ^ MUL[0x6][in[5]] ^ MUL[0x5][in[6]] ^ MUL[0x6][in[7]];
	temp[6] = MUL[0xB][in[4]] ^ MUL[0xE][in[5]] ^ MUL[0xA][in[6]] ^ MUL[0x9][in[7]];
	temp[7] = MUL[0x2][in[4]] ^ MUL[0x2][in[5]] ^ MUL[0xF][in[6]] ^ MUL[0xB][in[7]];

	temp[8]  = MUL[0x4][in[8]] ^ MUL[0x1][in[9]] ^ MUL[0x2][in[10]] ^ MUL[0x2][in[11]];
	temp[9]  = MUL[0x8][in[8]] ^ MUL[0x6][in[9]] ^ MUL[0x5][in[10]] ^ MUL[0x6][in[11]];
	temp[10] = MUL[0xB][in[8]] ^ MUL[0xE][in[9]] ^ MUL[0xA][in[10]] ^ MUL[0x9][in[11]];
	temp[11] = MUL[0x2][in[8]] ^ MUL[0x2][in[9]] ^ MUL[0xF][in[10]] ^ MUL[0xB][in[11]];

	temp[12] = MUL[0x4][in[12]] ^ MUL[0x1][in[13]] ^ MUL[0x2][in[14]] ^ MUL[0x2][in[15]];
	temp[13] = MUL[0x8][in[12]] ^ MUL[0x6][in[13]] ^ MUL[0x5][in[14]] ^ MUL[0x6][in[15]];
	temp[14] = MUL[0xB][in[12]] ^ MUL[0xE][in[13]] ^ MUL[0xA][in[14]] ^ MUL[0x9][in[15]];
	temp[15] = MUL[0x2][in[12]] ^ MUL[0x2][in[13]] ^ MUL[0xF][in[14]] ^ MUL[0xB][in[15]];

	//shift row
	out[0] = temp[0];
	out[4] = temp[4];
	out[8] = temp[8];
	out[12] = temp[12];

	out[1] = temp[5];
	out[5] = temp[9];
	out[9] = temp[13];
	out[13] = temp[1];

	out[2] = temp[10];
	out[6] = temp[14];
	out[10] = temp[2];
	out[14] = temp[6];

	out[3] = temp[15];
	out[7] = temp[3];
	out[11] = temp[7];
	out[15] = temp[11];
}


//w0, w4, w8, w12, w1, w5, w9, w13, w2, w6, w10, w14, w3, w7, w11, w15
//||  ||  ||   ||  ||  ||  ||   ||  ||  ||   ||   ||  ||  ||   ||   ||
//o0, o1, o2,  o3, o4, o5, o6,  o7, o8, o9, o10, o11,o12,o13, o14, o15
void LED64_inv_diffusion(DIFF_O_WRD_t * out, DIFF_I_WRD_t * in)
{
	DIFF_I_WRD_t temp[16];

	//inverse shift row
	temp[0] = in[0];
	temp[4] = in[4];
	temp[8] = in[8];
	temp[12] = in[12];

	temp[1] = in[13];
	temp[5] = in[1];
	temp[9] = in[5];
	temp[13] = in[9];

	temp[2] = in[10];
	temp[6] = in[14];
	temp[10] = in[2];
	temp[14] = in[6];

	temp[3] = in[7];
	temp[7] = in[11];
	temp[11] = in[15];
	temp[15] = in[3];

	/*
		D 9 9 D ^4  = C C D 4
		1 0 0 0       3 8 4 5
		0 1 0 0       7 6 2 E
		0 0 1 0       D 9 9 D
	*/

	//Inverse Mix Column
	out[0] = MUL[0xC][temp[0]] ^ MUL[0xC][temp[1]] ^ MUL[0xD][temp[2]] ^ MUL[0x4][temp[3]];
	out[1] = MUL[0x3][temp[0]] ^ MUL[0x8][temp[1]] ^ MUL[0x4][temp[2]] ^ MUL[0x5][temp[3]];
	out[2] = MUL[0x7][temp[0]] ^ MUL[0x6][temp[1]] ^ MUL[0x2][temp[2]] ^ MUL[0xE][temp[3]];
	out[3] = MUL[0xD][temp[0]] ^ MUL[0x9][temp[1]] ^ MUL[0x9][temp[2]] ^ MUL[0xD][temp[3]];

	out[4] = MUL[0xC][temp[4]] ^ MUL[0xC][temp[5]] ^ MUL[0xD][temp[6]] ^ MUL[0x4][temp[7]];
	out[5] = MUL[0x3][temp[4]] ^ MUL[0x8][temp[5]] ^ MUL[0x4][temp[6]] ^ MUL[0x5][temp[7]];
	out[6] = MUL[0x7][temp[4]] ^ MUL[0x6][temp[5]] ^ MUL[0x2][temp[6]] ^ MUL[0xE][temp[7]];
	out[7] = MUL[0xD][temp[4]] ^ MUL[0x9][temp[5]] ^ MUL[0x9][temp[6]] ^ MUL[0xD][temp[7]];

	out[8]  = MUL[0xC][temp[8]] ^ MUL[0xC][temp[9]] ^ MUL[0xD][temp[10]] ^ MUL[0x4][temp[11]];
	out[9]  = MUL[0x3][temp[8]] ^ MUL[0x8][temp[9]] ^ MUL[0x4][temp[10]] ^ MUL[0x5][temp[11]];
	out[10] = MUL[0x7][temp[8]] ^ MUL[0x6][temp[9]] ^ MUL[0x2][temp[10]] ^ MUL[0xE][temp[11]];
	out[11] = MUL[0xD][temp[8]] ^ MUL[0x9][temp[9]] ^ MUL[0x9][temp[10]] ^ MUL[0xD][temp[11]];

	out[12] = MUL[0xC][temp[12]] ^ MUL[0xC][temp[13]] ^ MUL[0xD][temp[14]] ^ MUL[0x4][temp[15]];
	out[13] = MUL[0x3][temp[12]] ^ MUL[0x8][temp[13]] ^ MUL[0x4][temp[14]] ^ MUL[0x5][temp[15]];
	out[14] = MUL[0x7][temp[12]] ^ MUL[0x6][temp[13]] ^ MUL[0x2][temp[14]] ^ MUL[0xE][temp[15]];
	out[15] = MUL[0xD][temp[12]] ^ MUL[0x9][temp[13]] ^ MUL[0x9][temp[14]] ^ MUL[0xD][temp[15]];

}


//w0, w4, w8, w12, w1, w5, w9, w13, w2, w6, w10, w14, w3, w7, w11, w15
//||  ||  ||   ||  ||  ||  ||   ||  ||  ||   ||   ||  ||  ||   ||   ||
//o0, o1, o2,  o3, o4, o5, o6,  o7, o8, o9, o10, o11,o12,o13, o14, o15
void LED64_inv_trans_diffusion(DIFF_O_WRD_t * out, DIFF_I_WRD_t * in)
{
	DIFF_I_WRD_t temp[16];

	/*
	D 9 9 D ^4 ^T  = C 3 7 D
	1 0 0 0          C 8 6 9
	0 1 0 0          D 4 2 9
	0 0 1 0          4 5 E D
	*/

	//Inverse Transpose Mix Column
	temp[0] = MUL[0xC][in[0]] ^ MUL[0x3][in[1]] ^ MUL[0x7][in[2]] ^ MUL[0xD][in[3]];
	temp[1] = MUL[0xC][in[0]] ^ MUL[0x8][in[1]] ^ MUL[0x6][in[2]] ^ MUL[0x9][in[3]];
	temp[2] = MUL[0xD][in[0]] ^ MUL[0x4][in[1]] ^ MUL[0x2][in[2]] ^ MUL[0x9][in[3]];
	temp[3] = MUL[0x4][in[0]] ^ MUL[0x5][in[1]] ^ MUL[0xE][in[2]] ^ MUL[0xD][in[3]];

	temp[4] = MUL[0xC][in[4]] ^ MUL[0x3][in[5]] ^ MUL[0x7][in[6]] ^ MUL[0xD][in[7]];
	temp[5] = MUL[0xC][in[4]] ^ MUL[0x8][in[5]] ^ MUL[0x6][in[6]] ^ MUL[0x9][in[7]];
	temp[6] = MUL[0xD][in[4]] ^ MUL[0x4][in[5]] ^ MUL[0x2][in[6]] ^ MUL[0x9][in[7]];
	temp[7] = MUL[0x4][in[4]] ^ MUL[0x5][in[5]] ^ MUL[0xE][in[6]] ^ MUL[0xD][in[7]];

	temp[8]  = MUL[0xC][in[8]] ^ MUL[0x3][in[9]] ^ MUL[0x7][in[10]] ^ MUL[0xD][in[11]];
	temp[9]  = MUL[0xC][in[8]] ^ MUL[0x8][in[9]] ^ MUL[0x6][in[10]] ^ MUL[0x9][in[11]];
	temp[10] = MUL[0xD][in[8]] ^ MUL[0x4][in[9]] ^ MUL[0x2][in[10]] ^ MUL[0x9][in[11]];
	temp[11] = MUL[0x4][in[8]] ^ MUL[0x5][in[9]] ^ MUL[0xE][in[10]] ^ MUL[0xD][in[11]];

	temp[12] = MUL[0xC][in[12]] ^ MUL[0x3][in[13]] ^ MUL[0x7][in[14]] ^ MUL[0xD][in[15]];
	temp[13] = MUL[0xC][in[12]] ^ MUL[0x8][in[13]] ^ MUL[0x6][in[14]] ^ MUL[0x9][in[15]];
	temp[14] = MUL[0xD][in[12]] ^ MUL[0x4][in[13]] ^ MUL[0x2][in[14]] ^ MUL[0x9][in[15]];
	temp[15] = MUL[0x4][in[12]] ^ MUL[0x5][in[13]] ^ MUL[0xE][in[14]] ^ MUL[0xD][in[15]];



	//shift row
	out[0] = temp[0];
	out[4] = temp[4];
	out[8] = temp[8];
	out[12] = temp[12];

	out[1] = temp[5];
	out[5] = temp[9];
	out[9] = temp[13];
	out[13] = temp[1];

	out[2] = temp[10];
	out[6] = temp[14];
	out[10] = temp[2];
	out[14] = temp[6];

	out[3] = temp[15];
	out[7] = temp[3];
	out[11] = temp[7];
	out[15] = temp[11];
}


//w0, w4, w8, w12, w1, w5, w9, w13, w2, w6, w10, w14, w3, w7, w11, w15
//||  ||  ||   ||  ||  ||  ||   ||  ||  ||   ||   ||  ||  ||   ||   ||
//o0, o1, o2,  o3, o4, o5, o6,  o7, o8, o9, o10, o11,o12,o13, o14, o15
void LED64_trans_diffusion(DIFF_O_WRD_t * out, DIFF_I_WRD_t * in)
{
	DIFF_I_WRD_t temp[16];

	//inverse shift row
	temp[0] = in[0];
	temp[4] = in[4];
	temp[8] = in[8];
	temp[12] = in[12];

	temp[1] = in[13];
	temp[5] = in[1];
	temp[9] = in[5];
	temp[13] = in[9];

	temp[2] = in[10];
	temp[6] = in[14];
	temp[10] = in[2];
	temp[14] = in[6];

	temp[3] = in[7];
	temp[7] = in[11];
	temp[11] = in[15];
	temp[15] = in[3];


	/*
		0 1 0 0 ^4 ^ T  = 4 8 B 2
		0 0 1 0           1 6 E 2
		0 0 0 1           2 5 A F
		4 1 2 2           2 6 9 B
	*/

	//Transpose Mix Column
	out[0] = MUL[0x4][temp[0]] ^ MUL[0x8][temp[1]] ^ MUL[0xB][temp[2]] ^ MUL[0x2][temp[3]];
	out[1] = MUL[0x1][temp[0]] ^ MUL[0x6][temp[1]] ^ MUL[0xE][temp[2]] ^ MUL[0x2][temp[3]];
	out[2] = MUL[0x2][temp[0]] ^ MUL[0x5][temp[1]] ^ MUL[0xA][temp[2]] ^ MUL[0xF][temp[3]];
	out[3] = MUL[0x2][temp[0]] ^ MUL[0x6][temp[1]] ^ MUL[0x9][temp[2]] ^ MUL[0xB][temp[3]];

	out[4] = MUL[0x4][temp[4]] ^ MUL[0x8][temp[5]] ^ MUL[0xB][temp[6]] ^ MUL[0x2][temp[7]];
	out[5] = MUL[0x1][temp[4]] ^ MUL[0x6][temp[5]] ^ MUL[0xE][temp[6]] ^ MUL[0x2][temp[7]];
	out[6] = MUL[0x2][temp[4]] ^ MUL[0x5][temp[5]] ^ MUL[0xA][temp[6]] ^ MUL[0xF][temp[7]];
	out[7] = MUL[0x2][temp[4]] ^ MUL[0x6][temp[5]] ^ MUL[0x9][temp[6]] ^ MUL[0xB][temp[7]];

	out[8]  = MUL[0x4][temp[8]] ^ MUL[0x8][temp[9]] ^ MUL[0xB][temp[10]] ^ MUL[0x2][temp[11]];
	out[9]  = MUL[0x1][temp[8]] ^ MUL[0x6][temp[9]] ^ MUL[0xE][temp[10]] ^ MUL[0x2][temp[11]];
	out[10] = MUL[0x2][temp[8]] ^ MUL[0x5][temp[9]] ^ MUL[0xA][temp[10]] ^ MUL[0xF][temp[11]];
	out[11] = MUL[0x2][temp[8]] ^ MUL[0x6][temp[9]] ^ MUL[0x9][temp[10]] ^ MUL[0xB][temp[11]];

	out[12] = MUL[0x4][temp[12]] ^ MUL[0x8][temp[13]] ^ MUL[0xB][temp[14]] ^ MUL[0x2][temp[15]];
	out[13] = MUL[0x1][temp[12]] ^ MUL[0x6][temp[13]] ^ MUL[0xE][temp[14]] ^ MUL[0x2][temp[15]];
	out[14] = MUL[0x2][temp[12]] ^ MUL[0x5][temp[13]] ^ MUL[0xA][temp[14]] ^ MUL[0xF][temp[15]];
	out[15] = MUL[0x2][temp[12]] ^ MUL[0x6][temp[13]] ^ MUL[0x9][temp[14]] ^ MUL[0xB][temp[15]];

}



#define LED64_DC_KNOWN_BEST_ROUND 0
void LED64_set_known_prob_bound(PROB_t * B)
{
	// 0Round :nothing
	B[0] = (PROB_t)0;
};

#define LED64_LC_KNOWN_BEST_ROUND 0
void LED64_set_known_corr_bound(CORR_t * B)
{
	// 0 Round :  nothing
	B[0].sign = POSI; B[0].magnitude = (ABS_CORR_t)0;
};


#define LED64_NUM_ROUND 48 //12 Steps which consist of 4 rounds
PROB_t LED64_each_round_initial_prob_bound[LED64_NUM_ROUND + 1] =
{
	(PROB_t)0,    //0-round
};
CORR_t LED64_each_round_initial_corr_bound[LED64_NUM_ROUND + 1] =
{
	{POSI, (ABS_CORR_t)0},		//0-round
};

SEARCHING_START_OPT_t LED64_searching_start_opt =
{
	/*enable_1round_active_map*/
	TRUE,
	/*rotational_symmetric_equivalent*/
	FALSE,
};

SET_INITIAL_BOUND_OPT_t LED64_set_initial_bound_opt =
{
	/*enable_set_initial_prob_bound*/
	FALSE,
	/*each_round_initial_prob_bound*/
	LED64_each_round_initial_prob_bound,
	/*prob_interval*/
	(PROB_t)-3,
	/*enable_set_initial_corr_bound*/
	FALSE,
	/*each_round_initial_corr_bound*/
	LED64_each_round_initial_corr_bound,
	/*corr_interval*/
	{POSI, (ABS_CORR_t)-2}
};

DIFFUSION_BOUND_OPT_t LED64_diffusion_bound_opt =
{
	/*num_diff_of_partial_diffusion*/
	4,
	/*diff_branch_num*/
	5,
	/*inv_trans_diff_branch_num*/
	5,
};

BLK_CIPHER_INFO_t LED64 =
{
	/*general information*/
	//algname
	"LED64",
	//alg_structure
	SPN,
	//num_round
	LED64_NUM_ROUND,
	//block_bit_size
	64,
	//key_bit_size
	128,
	//num_word_in_a_state
	16,

	/*about substitution*/
	//distinct_sbox
	FALSE,
	//sbox_i_word_bit_size
	4,
	//sbox_o_word_bit_size
	4,
	//sboxes
	LED64_sboxes,

	/*about diffusion*/
	//diffusion_info [what diffusion is used?(e.g., bit-permutation, matrix(partial), matrix(full))]
	PARTIAL_NON_BINARY_MATRIX, //MDS
	/*diff_i_word_bit_size*/
	4,
	/*diff_o_word_bit_size*/
	4,
	//diffusion functions
	//Diffusion(DIFF_O_WRD_t *, DIFF_I_WRD_t *)
	LED64_diffusion,
	//Inv_Diffusion(DIFF_I_WRD_t *, DIFF_O_WRD_t *)
	LED64_inv_diffusion,
	//Inv_Trans_Diffusion(DIFF_O_WRD_t *, DIFF_I_WRD_t *)
	LED64_inv_trans_diffusion,
	//Trans_Diffusion(DIFF_I_WRD_t *, DIFF_O_WRD_t *)
	LED64_trans_diffusion,

	/*about bound info*/
	//dc_known_best_round
	LED64_DC_KNOWN_BEST_ROUND,
	//Set_Known_Prob_Bound
	LED64_set_known_prob_bound,
	//lc_known_best_round
	LED64_LC_KNOWN_BEST_ROUND,
	//Set_Known_Corr_Bound
	LED64_set_known_corr_bound,
	/*start searching opt ptr*/
	&LED64_searching_start_opt,
	&LED64_set_initial_bound_opt,
	&LED64_diffusion_bound_opt
};


void PY_LED64_DC_Prob_Searching(PROB_t * rst, CNT_t num_round, UFLAG_t verbose)
{
	SPN_Prep_Info_For_DC(&LED64);
#ifdef EMPLOY_PERM_CHAR
	Use_Predefined_1Round_Active_Maps_LED64(&LED64);
#else
	Use_Predefined_1Round_Active_Maps(&LED64);
#endif
	SPN_Best_DC_Prob_Search(rst, &LED64, 0, num_round, verbose);
}

void PY_LED64_LC_Corr_Searching(CORR_t * rst, CNT_t num_round, UFLAG_t verbose)
{
	SPN_Prep_Info_For_LC(&LED64);
#ifdef EMPLOY_PERM_CHAR
	Use_Predefined_1Round_Active_Maps_LED64(&LED64);
#else
	Use_Predefined_1Round_Active_Maps(&LED64);
#endif
	SPN_Best_LC_Corr_Search(rst, &LED64, 0, num_round, verbose);
}